================================================================================
C++ DATAFRAME DOCUMENTATION
================================================================================
Title: C++ DataFrame Library - Comprehensive Documentation
Description: Complete documentation for C++ DataFrame library for statistical analysis, machine learning, financial data processing, and data science applications
Keywords: C++ DataFrame, data analysis, statistical computing, machine learning, financial analysis, heterogeneous container, templated library, data science, quantitative analysis, time series
Version: Latest
Repository: https://github.com/hosseinmoein/DataFrame
Website: https://hosseinmoein.github.io/DataFrame/
License: BSD-3-Clause
Language: C++23
Platform: Cross-platform (Linux, Windows, macOS)

================================================================================
TABLE OF CONTENTS
================================================================================

1. INTRODUCTION AND OVERVIEW
   1.1 What is C++ DataFrame
   1.2 Core Features and Capabilities
   1.3 Data Structure and Schema
   1.4 Key Characteristics

2. LIBRARY ARCHITECTURE
   2.1 Template Parameters
   2.2 Index Column Concept
   2.3 Heterogeneous Vector Types
   2.4 Memory Alignment Options
   2.5 DataFrame Views

3. DATETIME SUPPORT
   3.1 DateTime Class Overview
   3.2 Features and Capabilities

4. API REFERENCE
   4.1 API Categories
   4.2 Data Access and Manipulation
   4.3 Analytical Algorithms and Visitors

5. MULTITHREADING AND PERFORMANCE
   5.1 Overview
   5.2 User Multithreading
   5.3 DataFrame Internal Multithreading
   5.4 Thread Pool Configuration
   5.5 Asynchronous Interfaces

6. VISITORS PATTERN
   6.1 Concept and Purpose
   6.2 Implementation Details

7. MEMORY ALIGNMENT AND SIMD OPTIMIZATION
   7.1 Custom Memory Alignment
   7.2 SIMD Instructions Support
   7.3 Performance Optimization
   7.4 Cache Line Optimization

8. NUMERIC GENERATORS
   8.1 Random Number Generation
   8.2 Distribution Support
   8.3 Usage Examples

9. BUILD INSTRUCTIONS
   9.1 Build Types
   9.2 CMake Build System
   9.3 Package Manager Installation
   9.4 Alternative Build Methods
   9.5 Testing and Validation

================================================================================
1. INTRODUCTION AND OVERVIEW
================================================================================

1.1 WHAT IS C++ DATAFRAME
-------------------------

DataFrame is a high-performance, templatized, and heterogeneous C++ container 
specifically designed for data analysis in statistical, machine-learning, and 
financial applications.

Primary Use Cases:
• Statistical data analysis and processing
• Machine learning data preparation and feature engineering
• Financial time series analysis and algorithmic trading
• Quantitative research and analytics
• Scientific computing and data science workflows
• Big data processing in C++ applications

Data Structure Paradigm:
Think of DataFrame as a two-dimensional data structure of columns and rows, 
similar to:
• Excel spreadsheet
• SQL database table
• Python Pandas DataFrame
• R data.frame

However, C++ DataFrame extends beyond two dimensions. Columns can contain 
vectors of any type, including other DataFrames or custom containers, enabling 
multi-dimensional data structures.


1.2 CORE FEATURES AND CAPABILITIES
-----------------------------------

Column-First Design:
Columns are first-class citizens in DataFrame. Operations and access to columns 
are significantly more efficient and easier than row-by-row data manipulation. 
This design choice optimizes for:
• Vectorized operations
• Cache-efficient processing
• SIMD instruction utilization
• Parallel computation

Intuitive Analytics API:
The API is designed to be:
• Open-ended and extensible
• Easy to integrate custom algorithms
• Consistent across different operations
• Type-safe at compile time


1.3 DATA STRUCTURE AND SCHEMA
------------------------------

Schema Management:
Every DataFrame inherently includes a schema that can be:
• Built dynamically at runtime
• Loaded from external files
• Serialized and transmitted across network nodes
• Reconstructed on remote systems

Distribution and Serialization:
DataFrame supports sharing between different nodes (computers) through:
• File-based persistence
• In-memory serialization to buffers
• Network transmission and reconstruction


1.4 KEY CHARACTERISTICS
-----------------------

Structural Properties:
• Single index column with multiple data columns
• Supports any built-in or user-defined types
• Each data column can be at most as long as the index column
• Columns maintain creation order (modifiable through rotation)
• Column access requires compile-time type knowledge

Type Safety:
To access a column for any operation, you must know:
• Column name (or index position)
• Column data type at compile time

Getting Started Resources:
• Hello World examples
• Cheat Sheet for common operations
• DataFrame Library Types reference

Interfaces:
• Synchronous methods for immediate execution
• Asynchronous methods returning std::future
• Thread-safe operations (with proper configuration)

IMPORTANT: Before production use, thoroughly review these sections:
• Multithreading configuration and best practices
• Views and memory management
• Visitors pattern for analytical operations
• Memory alignment for performance optimization


================================================================================
2. LIBRARY ARCHITECTURE
================================================================================

2.1 TEMPLATE PARAMETERS
-----------------------

DataFrame Class Definition:
    template<typename I, typename H>
    class DataFrame;

Template Parameter I (Index Type):
Specifies the index column type. The index in DataFrame differs from SQL 
database indices:

SQL Database Index:
• Makes data access efficient
• Doesn't provide additional information
• Used primarily for lookup optimization

DataFrame Index Column:
• Metadata describing each row
• Provides contextual information about data points
• Examples: timestamps, frequencies, measurement conditions
• Can be composite structures (e.g., struct with temperature, altitude, etc.)

Template Parameter H (Heterogeneous Vector):
Specifies the heterogeneous vector type for containing DataFrame columns.

Note: Don't get overwhelmed by H's complexity. Use the convenient typedef's 
provided in DataFrame Library Types documentation.


2.2 INDEX COLUMN CONCEPT
-------------------------

The index column serves as metadata providing context for each row:
• Time series: timestamps or date-time values
• Frequency domain: frequency bins or wavelengths
• Experimental data: measurement conditions (temperature, pressure, etc.)
• Multi-dimensional: composite descriptors in custom structs


2.3 HETEROGENEOUS VECTOR TYPES
-------------------------------

H Template Parameter Options:

1. HeteroVector<std::size_t A = 0>
   • Actual heterogeneous vector containing data
   • Results in a "standard" DataFrame
   • Owns the data
   • Full modification capabilities

2. HeteroPtrView<std::size_t A = 0>
   • Heterogeneous vector view
   • Non-contiguous view into another DataFrame slice
   • Disjointed data access
   • Lightweight reference

3. HeteroConstPtrView<std::size_t A = 0>
   • Const version of HeteroPtrView
   • Read-only access
   • Prevents data modification

4. HeteroView<std::size_t A = 0>
   • Heterogeneous vector view
   • Contiguous slice of another DataFrame
   • More efficient than HeteroPtrView
   • Sequential data access

5. HeteroConstView<std::size_t A = 0>
   • Const version of HeteroView
   • Read-only contiguous access


2.4 MEMORY ALIGNMENT OPTIONS
-----------------------------

Template Parameter A:
Specifies byte boundary alignment for memory allocations.

Default Behavior:
• A = 0: Uses system default alignment boundaries for each type

Custom Alignment:
• Enables SIMD instruction optimization
• Prevents false cache-line sharing
• Improves performance for vectorized operations

See sections:
• DataFrame Library Types for convenient typedef's
• Memory Alignment section for detailed information


2.5 DATAFRAME VIEWS
-------------------

DataFrame methods may return:
• New DataFrame instances
• View instances (HeteroPtrView, HeteroView, etc.)

User Perspective:
DataFrame and view instances are designed to be indistinguishable from the 
user's perspective. Views provide:
• Efficient data slicing without copying
• Memory-efficient data access
• Consistent API across DataFrame and views

Resources:
• Views section (detailed documentation)
• DataFrame Library Types (convenient typedef's)
• Library-wide Types section


================================================================================
3. DATETIME SUPPORT
================================================================================

3.1 DATETIME CLASS OVERVIEW
----------------------------

The included DateTime class provides powerful date and time manipulation 
capabilities:

Precision: Nanosecond-level accuracy
Timezone Support: Multi-timezone handling
Interface: Simple and intuitive


3.2 FEATURES AND CAPABILITIES
------------------------------

Component Manipulation:
• Break date/time into individual components (year, month, day, hour, etc.)
• Reassemble date/time from components
• Convert between different representations

Time Operations:
• Advance or pull back with different granularities
• Calculate time differences
• Timezone conversions
• Daylight saving time handling

For comprehensive DateTime documentation, see dedicated DateTime reference.


================================================================================
4. API REFERENCE
================================================================================

4.1 API CATEGORIES
------------------

The DataFrame library interface is organized into two main categories:

Category 1: Data Manipulation and Access
• Accessing columns and rows
• Adding and removing data
• Slicing and dicing operations
• Joining DataFrames
• Group-by operations
• Sorting and filtering
• Data transformation

Category 2: Analytical Algorithms
• Statistical analysis methods
• Machine learning algorithms
• Financial analysis tools
• Custom algorithm integration


4.2 DATA ACCESS AND MANIPULATION
---------------------------------

Implementation Approach:
Regular parameterized methods (member functions) implement data manipulation 
operations.

Common Operations:
• Column selection and filtering
• Row-based operations
• Multi-column transformations
• Data aggregation
• Reshaping and pivoting


4.3 ANALYTICAL ALGORITHMS AND VISITORS
---------------------------------------

Implementation Approach:
The Visitor Pattern is employed for analytical algorithms.

Advantages:
• Type-safe algorithm execution
• Extensible design for custom algorithms
• Efficient parallel processing
• Separation of concerns

For comprehensive documentation:
See the complete reference table listing all methods, visitors, and types 
with code samples.


================================================================================
5. MULTITHREADING AND PERFORMANCE
================================================================================

5.1 OVERVIEW
------------

Multithreading Best Practices:
Multithreading can be counterintuitive. Adding threads doesn't automatically 
improve performance and can sometimes hinder it.

Effective Multithreading Requirements:
1. Measure performance metrics
2. Adjust based on measurements
3. Iterate and optimize

When to Use Multithreading:

Scenario 1 - CPU-Bound Operations:
• Intensive mathematical computations
• Independent calculations utilizing different cores
• Parallelizable algorithms

Scenario 2 - I/O-Bound Operations:
• Multiple independent I/O operations
• Operations that can proceed while waiting
• Network or disk-intensive tasks

Critical Success Factor: Independence
Operations must be independent to benefit from parallelization.

Multithreading Overhead:
• Inherent performance cost
• Affects current process and system-wide resources
• Thread creation and synchronization costs

Recommended Development Approach:
1. Start with single-threaded implementation
2. Verify correctness
3. Establish performance baseline
4. Take detailed measurements
5. Implement multithreaded solution
6. Compare and validate improvements


5.2 USER MULTITHREADING
-----------------------

Responsibility:
Users are responsible for synchronizing shared DataFrame resources.

Thread Safety:
DataFrame is NOT thread-safe by default. This applies to:
• Static data structures
• Per-instance data

Static Container Protection:

Default Behavior:
• Static containers are unprotected (by design)
• No locking overhead by default
• Maximum performance for single-threaded use

Multithreaded Applications:
Must provide SpinLock (defined in ThreadGranularity.h)

Protection Steps:
1. Implement custom SpinLock
2. Register with DataFrame using set_lock()
3. Remove with remove_lock() when done
4. See dataframe_tester.cc#3767 for code example

This protects DataFrame static structures only.

Instance-Level Protection:

Requirements:
• Individual DataFrame instances need separate protection
• Not safe for concurrent access by multiple threads
• Exception: Read-only access is safe

User Responsibility:
• Implement your own locking mechanism
• Design synchronization logic
• DataFrame doesn't provide instance-level locking API


5.3 DATAFRAME INTERNAL MULTITHREADING
--------------------------------------

Thread Pool Architecture:
DataFrame uses a versatile thread pool for parallel computing across almost 
all APIs.

Default Behavior:
• No multithreading enabled by default
• All algorithms execute single-threaded versions
• Thread pool is initially empty

Enabling Multithreading:

Option 1 - Automatic Optimization (Recommended):
    ThreadGranularity::set_optimum_thread_level()

Option 2 - Manual Configuration:
    ThreadGranularity::set_thread_level(n)


5.4 THREAD POOL CONFIGURATION
------------------------------

Activation Thresholds:
When multithreading is enabled, parallel algorithms trigger when:
• Data points exceed 250,000
• Thread count exceeds 2

Small Dataset Optimization:
For datasets smaller than 250k rows:
• Single-threaded execution is more efficient
• Thread pool overhead outweighs benefits
• No need to populate thread pool

Automatic Synchronization:
• Internal synchronization handled automatically
• No user intervention required
• Thread-safe internal operations

Static Properties:
• Thread pool is static across all DataFrame instances
• Thread level applies globally
• Set once, applies everywhere


5.5 ASYNCHRONOUS INTERFACES
----------------------------

Available Async Methods:
• sort() → sort_async()
• visit() → visit_async()
• Many other operations have async variants

Return Type:
Async methods return std::future for parallel execution

Recommended Configuration:
    ThreadGranularity::set_optimum_thread_level()

Important: If thread pool is empty when async methods are called:
• Single thread will be added automatically
• Suboptimal performance with only one thread
• May actually hinder performance

Best Practice:
Always configure thread pool optimally before using async interfaces.


================================================================================
6. VISITORS PATTERN
================================================================================

6.1 CONCEPT AND PURPOSE
-----------------------

Design Pattern:
The Visitor Pattern separates algorithms from the data structures they 
operate on.

Benefits in DataFrame:
• Type-safe algorithm execution
• Easy addition of new algorithms
• Consistent interface across operations
• Efficient parallel processing
• Clean separation of concerns

Use Cases:
• Statistical calculations
• Machine learning algorithms
• Financial indicators
• Custom analytical functions


6.2 IMPLEMENTATION DETAILS
---------------------------

For detailed visitor implementation and usage, see dedicated Visitors 
documentation section.


================================================================================
7. MEMORY ALIGNMENT AND SIMD OPTIMIZATION
================================================================================

7.1 CUSTOM MEMORY ALIGNMENT
----------------------------

Capability:
DataFrame provides custom memory alignment allocation on specified byte 
boundaries.

Primary Benefits:
• SIMD instruction optimization
• Vectorized operations support
• Cache-line optimization


7.2 SIMD INSTRUCTIONS SUPPORT
------------------------------

SIMD Definition:
Single Instruction, Multiple Data - A parallel processing technique where one 
CPU instruction processes multiple data points simultaneously.

Traditional Scalar Operations:
• Process one data point at a time
• Sequential execution
• Lower throughput

SIMD Vectorized Operations:
• Process multiple data points simultaneously
• Parallel execution within single instruction
• Higher computational throughput

DataFrame Advantage:
All DataFrame algorithms operate on vectors (columns), making SIMD optimization 
highly effective when combined with compiler optimizations.


7.3 PERFORMANCE OPTIMIZATION
-----------------------------

Historical Context:
• Initial SIMD implementations: 1990s
• Intel SSE (Streaming SIMD Extensions): Enhanced SIMD capabilities
• Intel AVX (Advanced Vector Extensions): Further expanded SIMD support
• Modern CPUs: Extensive SIMD instruction sets

Alignment Options:
Convenient typedef's define DataFrames with different alignment boundaries:
• 64-byte alignment
• 128-byte alignment
• 256-byte alignment
• Custom alignments

Optimal Alignment:
Depends on your system's cache line width. Experiment for best results.


7.4 CACHE LINE OPTIMIZATION
----------------------------

False Sharing Prevention:
Custom alignment can prevent false cache-line sharing between multiple columns.

Performance Impact:
• Reduced cache invalidation
• Better memory access patterns
• Improved multi-core performance

Access Pattern:
When accessing columns, you receive a reference to StlVecType (std::vector with 
custom allocator for requested alignment).

Resources:
See DataFrame Library Types documentation for alignment typedef's.


================================================================================
8. NUMERIC GENERATORS
================================================================================

8.1 RANDOM NUMBER GENERATION
-----------------------------

Purpose:
Convenient standalone functions for generating random numbers with various 
statistical distributions.

Integration:
Seamlessly generate random DataFrame columns with these utilities.


8.2 DISTRIBUTION SUPPORT
-------------------------

Features:
• Multiple probability distributions
• Space-optimized result vectors
• Configurable memory alignment
• High-performance generation


8.3 USAGE EXAMPLES
------------------

Documentation Resources:
• Dedicated generator documentation
• RandGen.h header file
• dataframe_tester.cc examples
• RandGenParams definition in DataFrameTypes.h

Configuration:
See DataFrameTypes.h for RandGenParams definition and default values.


================================================================================
9. BUILD INSTRUCTIONS
================================================================================

9.1 BUILD TYPES
---------------

Sanity Checks Configuration:

Compile-time Flag: HMDF_SANITY_EXCEPTIONS=1

With HMDF_SANITY_EXCEPTIONS Defined:
• Runtime dimensionality checks
• Data validation
• Explanatory exceptions on errors
• Debugging assistance

Example Error Scenario:
Calling KNN with K greater than available data points:
• With flag: Descriptive exception thrown
• Without flag: Garbage results or crash

Without HMDF_SANITY_EXCEPTIONS:
• No runtime checks
• Assumes bug-free code
• Maximum performance
• Risk of mysterious crashes

Recommendation:
Always use HMDF_SANITY_EXCEPTIONS during development and testing. Only disable 
in thoroughly tested production code.

Build Configuration Types:

1. Debug Build:
   • Debug information included
   • No optimizations
   • Larger executable files
   • Significantly slower execution
   • Full debugging capabilities

2. Release Build:
   • Full compiler optimizations
   • No debug information
   • Smaller executable files
   • Significantly faster execution
   • Limited crash diagnostics

3. Custom Build:
   • User-defined optimization levels
   • Custom debug information
   • Experimental configurations


9.2 CMAKE BUILD SYSTEM
----------------------

Repository Setup:

Clone Repository:
    git clone https://github.com/hosseinmoein/DataFrame.git

CMake Build Process:

Create Build Directory:
    mkdir [Debug|Release]
    cd [Debug|Release]

Release Build (Optimized):

Without Sanity Checks:
    cmake -DCMAKE_BUILD_TYPE=Release \
          -DHMDF_BENCHMARKS=1 \
          -DHMDF_EXAMPLES=1 \
          -DHMDF_TESTING=1 ..

With Sanity Checks:
    cmake -DCMAKE_BUILD_TYPE=Release \
          -DHMDF_SANITY_EXCEPTIONS=1 \
          -DHMDF_BENCHMARKS=1 \
          -DHMDF_EXAMPLES=1 \
          -DHMDF_TESTING=1 ..

Debug Build:
    cmake -DCMAKE_BUILD_TYPE=Debug \
          -DHMDF_SANITY_EXCEPTIONS=1 \
          -DHMDF_BENCHMARKS=1 \
          -DHMDF_EXAMPLES=1 \
          -DHMDF_TESTING=1 ..

Compile and Install:
    make
    make install

Uninstall:
    cd [Debug|Release]
    make uninstall


9.3 PACKAGE MANAGER INSTALLATION
---------------------------------

Conan Platform:
DataFrame is available on Conan package manager.
See Conan documentation for installation and usage instructions.

VCPKG Platform:
DataFrame is available on VCPKG package manager.
See VCPKG documentation for installation and usage instructions.


9.4 ALTERNATIVE BUILD METHODS
------------------------------

Plain Make (Not Recommended):

Process:
1. Navigate to src subdirectory
2. Execute build_all.sh script
3. Builds library and test executables

Limitations:
• Linux/Unix flavors only
• Less flexible than CMake
• Manual dependency management


9.5 TESTING AND VALIDATION
---------------------------

Test Data Requirements:

Location:
Test programs in test/, examples/, and benchmarks/ directories require mock 
data files from the data/ directory.

Important:
• Data files must be in current directory when running tests
• CMake automatically copies data files to execution directory
• Manual execution requires data/ as current directory

Test Execution:
If running tests manually, ensure data/ directory is your current working 
directory.


================================================================================
ADDITIONAL RESOURCES
================================================================================

Documentation:
• Complete API Reference: https://hosseinmoein.github.io/DataFrame/docs/HTML/DataFrame.html
• GitHub Repository: https://github.com/hosseinmoein/DataFrame
• Issue Tracker: https://github.com/hosseinmoein/DataFrame/issues
• Discussions: https://github.com/hosseinmoein/DataFrame/discussions

Quick Start:
• Hello World Examples
• Cheat Sheet PDF
• Sample Code in examples/ directory
• Test Suite in test/ directory

Support:
• GitHub Issues for bug reports
• GitHub Discussions for questions
• Documentation for comprehensive guides

Contributing:
• Pull requests welcome
• See contribution guidelines
• Test coverage required
• Documentation updates appreciated


================================================================================
KEYWORDS FOR SEARCH OPTIMIZATION
================================================================================

Primary Keywords:
C++ DataFrame, data analysis C++, statistical computing C++, machine learning C++,
financial data analysis, time series analysis C++, quantitative analysis,
heterogeneous container C++, templated DataFrame, data science C++

Secondary Keywords:
pandas alternative C++, R dataframe C++, columnar data structure, vectorized operations,
SIMD optimization, parallel computing C++, thread-safe DataFrame, high-performance analytics,
big data C++, numerical computing, statistical library C++, trading algorithms

Technical Keywords:
template metaprogramming, visitor pattern, memory alignment, cache optimization,
multithreading C++, async operations, compile-time type safety, heterogeneous storage,
STL containers, modern C++, C++20, C++23

Application Domains:
quantitative finance, algorithmic trading, data science, machine learning pipeline,
statistical analysis, time series forecasting, financial engineering, risk analysis,
backtesting, market data analysis


================================================================================
END OF DOCUMENTATION
================================================================================
Last Updated: 2024
For latest version, visit: https://github.com/hosseinmoein/DataFrame
